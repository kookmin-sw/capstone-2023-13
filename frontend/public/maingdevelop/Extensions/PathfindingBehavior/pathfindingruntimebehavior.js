var gdjs;(function(l){const p=new l.Logger("Pathfinding behavior");class f extends l.RuntimeBehavior{constructor(s,e,o){super(s,e,o);this._path=[];this._pathFound=!1;this._speed=0;this._angularSpeed=0;this._distanceOnSegment=0;this._totalSegmentDistance=0;this._currentSegment=0;this._reachedEnd=!1;this._movementAngle=0;this._path===void 0||(this._path.length=0),this._allowDiagonals=e.allowDiagonals,this._acceleration=e.acceleration,this._maxSpeed=e.maxSpeed,this._angularMaxSpeed=e.angularMaxSpeed,this._rotateObject=e.rotateObject,this._angleOffset=e.angleOffset,this._cellWidth=e.cellWidth,this._cellHeight=e.cellHeight,this._gridOffsetX=e.gridOffsetX||0,this._gridOffsetY=e.gridOffsetY||0,this._extraBorder=e.extraBorder,this._smoothingMaxCellGap=e.smoothingMaxCellGap||0,this._manager=l.PathfindingObstaclesManager.getManager(s),this._searchContext=new l.PathfindingRuntimeBehavior.SearchContext(this._manager)}updateFromBehaviorData(s,e){return s.allowDiagonals!==e.allowDiagonals&&this.allowDiagonals(e.allowDiagonals),s.acceleration!==e.acceleration&&this.setAcceleration(e.acceleration),s.maxSpeed!==e.maxSpeed&&this.setMaxSpeed(e.maxSpeed),s.angularMaxSpeed!==e.angularMaxSpeed&&this.setAngularMaxSpeed(e.angularMaxSpeed),s.rotateObject!==e.rotateObject&&this.setRotateObject(e.rotateObject),s.angleOffset!==e.angleOffset&&this.setAngleOffset(e.angleOffset),s.cellWidth!==e.cellWidth&&this.setCellWidth(e.cellWidth),s.cellHeight!==e.cellHeight&&this.setCellHeight(e.cellHeight),s.gridOffsetX!==e.gridOffsetX&&(this._gridOffsetX=e.gridOffsetX),s.gridOffsetY!==e.gridOffsetY&&(this._gridOffsetY=e.gridOffsetY),s.extraBorder!==e.extraBorder&&this.setExtraBorder(e.extraBorder),s.smoothingMaxCellGap!==e.smoothingMaxCellGap&&(this._smoothingMaxCellGap=e.smoothingMaxCellGap),!0}setCellWidth(s){this._cellWidth=s}getCellWidth(){return this._cellWidth}setCellHeight(s){this._cellHeight=s}getCellHeight(){return this._cellHeight}setGridOffsetX(s){this._gridOffsetX=s}getGridOffsetX(){return this._gridOffsetX}setGridOffsetY(s){this._gridOffsetY=s}getGridOffsetY(){return this._gridOffsetY}setAcceleration(s){this._acceleration=s}getAcceleration(){return this._acceleration}setMaxSpeed(s){this._maxSpeed=s}getMaxSpeed(){return this._maxSpeed}setSpeed(s){this._speed=s}getSpeed(){return this._speed}getMovementAngle(){return this._movementAngle}movementAngleIsAround(s,e){return Math.abs(l.evtTools.common.angleDifference(this._movementAngle,s))<=e}setAngularMaxSpeed(s){this._angularMaxSpeed=s}getAngularMaxSpeed(){return this._angularMaxSpeed}setAngleOffset(s){this._angleOffset=s}getAngleOffset(){return this._angleOffset}setExtraBorder(s){this._extraBorder=s}getExtraBorder(){return this._extraBorder}allowDiagonals(s){this._allowDiagonals=s}diagonalsAllowed(){return this._allowDiagonals}setRotateObject(s){this._rotateObject=s}isObjectRotated(){return this._rotateObject}getNodeX(s){return s<this._path.length?this._path[s][0]:0}getNodeY(s){return s<this._path.length?this._path[s][1]:0}getNextNodeIndex(){return this._currentSegment+1<this._path.length?this._currentSegment+1:this._path.length-1}getNodeCount(){return this._path.length}getNextNodeX(){return this._path.length===0?0:this._currentSegment+1<this._path.length?this._path[this._currentSegment+1][0]:this._path[this._path.length-1][0]}getNextNodeY(){return this._path.length===0?0:this._currentSegment+1<this._path.length?this._path[this._currentSegment+1][1]:this._path[this._path.length-1][1]}getLastNodeX(){return this._path.length<2?0:this._currentSegment<this._path.length-1?this._path[this._currentSegment][0]:this._path[this._path.length-1][0]}getLastNodeY(){return this._path.length<2?0:this._currentSegment<this._path.length-1?this._path[this._currentSegment][1]:this._path[this._path.length-1][1]}getDestinationX(){return this._path.length===0?0:this._path[this._path.length-1][0]}getDestinationY(){return this._path.length===0?0:this._path[this._path.length-1][1]}pathFound(){return this._pathFound}destinationReached(){return this._reachedEnd}moveTo(s,e,o){const t=this.owner,i=Math.round((e-this._gridOffsetX)/this._cellWidth),h=Math.round((o-this._gridOffsetY)/this._cellHeight),r=Math.round((t.getX()-this._gridOffsetX)/this._cellWidth),n=Math.round((t.getY()-this._gridOffsetY)/this._cellHeight);if(r==i&&n==h){this._path.length=0,this._path.push([t.getX(),t.getY()]),this._path.push([e,o]),this._enterSegment(0),this._pathFound=!0;return}if(this._searchContext.allowDiagonals(this._allowDiagonals),this._searchContext.setObstacles(this._manager),this._searchContext.setCellSize(this._cellWidth,this._cellHeight),this._searchContext.setGridOffset(this._gridOffsetX,this._gridOffsetY),this._searchContext.setStartPosition(t.getX(),t.getY()),this._searchContext.setObjectSize(t.getX()-t.getDrawableX()+this._extraBorder,t.getY()-t.getDrawableY()+this._extraBorder,t.getWidth()-(t.getX()-t.getDrawableX())+this._extraBorder,t.getHeight()-(t.getY()-t.getDrawableY())+this._extraBorder),this._searchContext.computePathTo(e,o)){let a=this._searchContext.getFinalNode(),_=0;for(;a;)_===this._path.length&&this._path.push([0,0]),this._path[_][0]=a.pos[0]*this._cellWidth+this._gridOffsetX,this._path[_][1]=a.pos[1]*this._cellHeight+this._gridOffsetY,a=a.parent,_++;if(this._path.length=_,this._path.reverse(),this._path[0][0]=t.getX(),this._path[0][1]=t.getY(),this._allowDiagonals&&this._smoothingMaxCellGap>0){l.pathfinding.simplifyPath(this._path,this._smoothingMaxCellGap*Math.min(this._cellWidth,this._cellHeight),l.PathfindingRuntimeBehavior._smoothingResultVertices,l.PathfindingRuntimeBehavior._smoothingWorkingVertices);let g=this._path;this._path=l.PathfindingRuntimeBehavior._smoothingResultVertices,l.PathfindingRuntimeBehavior._smoothingResultVertices=g}this._enterSegment(0),this._pathFound=!0;return}this._pathFound=!1}_enterSegment(s){if(this._path.length!==0)if(this._currentSegment=s,this._currentSegment<this._path.length-1){const e=this._path[this._currentSegment+1][0]-this._path[this._currentSegment][0],o=this._path[this._currentSegment+1][1]-this._path[this._currentSegment][1];this._totalSegmentDistance=Math.sqrt(e*e+o*o),this._distanceOnSegment=0,this._reachedEnd=!1,this._movementAngle=(l.toDegrees(Math.atan2(o,e))+360)%360}else this._reachedEnd=!0,this._speed=0}doStepPreEvents(s){if(this._path.length===0||this._reachedEnd)return;const e=this.owner.getElapsedTime()/1e3,o=this._speed;this._speed!==this._maxSpeed&&(this._speed+=this._acceleration*e,this._speed>this._maxSpeed&&(this._speed=this._maxSpeed)),this._angularSpeed=this._angularMaxSpeed,this._distanceOnSegment+=(this._speed+o)/2*e;const t=this._totalSegmentDistance-this._distanceOnSegment;t<=0&&this._currentSegment<this._path.length&&(this._enterSegment(this._currentSegment+1),this._distanceOnSegment=-t);let i=[0,0];this._currentSegment<this._path.length-1?(i[0]=l.evtTools.common.lerp(this._path[this._currentSegment][0],this._path[this._currentSegment+1][0],this._distanceOnSegment/this._totalSegmentDistance),i[1]=l.evtTools.common.lerp(this._path[this._currentSegment][1],this._path[this._currentSegment+1][1],this._distanceOnSegment/this._totalSegmentDistance),this._rotateObject&&this.owner.getAngle()!==this._movementAngle+this._angleOffset&&this.owner.rotateTowardAngle(this._movementAngle+this._angleOffset,this._angularSpeed)):i=this._path[this._path.length-1],this.owner.setX(i[0]),this.owner.setY(i[1])}doStepPostEvents(s){}static euclideanDistance(s,e){return Math.sqrt((s[0]-e[0])*(s[0]-e[0])+(s[1]-e[1])*(s[1]-e[1]))}static manhattanDistance(s,e){return Math.abs(s[0]-e[0])+Math.abs(s[1]-e[1])}}f._smoothingResultVertices=[],f._smoothingWorkingVertices=[],l.PathfindingRuntimeBehavior=f,l.registerBehavior("PathfindingBehavior::PathfindingBehavior",l.PathfindingRuntimeBehavior),function(e){class c{constructor(t,i){this.cost=0;this.smallestCost=-1;this.estimateCost=-1;this.parent=null;this.open=!0;this.pos=[t,i]}reinitialize(t,i){this.pos[0]=t,this.pos[1]=i,this.cost=0,this.smallestCost=-1,this.estimateCost=-1,this.parent=null,this.open=!0}}e.Node=c;class s{constructor(t){this._finalNode=null;this._destination=[0,0];this._start=[0,0];this._startX=0;this._startY=0;this._allowDiagonals=!0;this._maxComplexityFactor=50;this._cellWidth=20;this._cellHeight=20;this._gridOffsetX=0;this._gridOffsetY=0;this._leftBorder=0;this._rightBorder=0;this._topBorder=0;this._bottomBorder=0;this._allNodes=[];this._openNodes=[];this._closeObstacles=[];this._nodeCache=[];this._obstacles=t,this._distanceFunction=e.euclideanDistance}setObstacles(t){return this._obstacles=t,this}getFinalNode(){return this._finalNode}allowDiagonals(t){return this._allowDiagonals=t,this._distanceFunction=t?e.euclideanDistance:e.manhattanDistance,this}setStartPosition(t,i){return this._startX=t,this._startY=i,this}setObjectSize(t,i,h,r){return this._leftBorder=t,this._rightBorder=h,this._topBorder=i,this._bottomBorder=r,this}setCellSize(t,i){return this._cellWidth=t,this._cellHeight=i,this}setGridOffset(t,i){return this._gridOffsetX=t,this._gridOffsetY=i,this}computePathTo(t,i){if(this._obstacles===null){p.log("You tried to compute a path without specifying the obstacles");return}this._destination[0]=Math.round((t-this._gridOffsetX)/this._cellWidth),this._destination[1]=Math.round((i-this._gridOffsetY)/this._cellHeight),this._start[0]=Math.round((this._startX-this._gridOffsetX)/this._cellWidth),this._start[1]=Math.round((this._startY-this._gridOffsetY)/this._cellHeight),this._freeAllNodes();const h=this._getNode(this._start[0],this._start[1]);h.smallestCost=0,h.estimateCost=0+this._distanceFunction(this._start,this._destination),this._openNodes.length=0,this._openNodes.push(h);let r=0;const n=h.estimateCost*this._maxComplexityFactor;for(;this._openNodes.length!==0;){if(r++>n)return console.warn(`No path was found after covering ${n} cells.`),!1;const a=this._openNodes.shift();if(a.open=!1,a.pos[0]==this._destination[0]&&a.pos[1]==this._destination[1])return this._finalNode=a,!0;this._insertNeighbors(a)}return!1}_freeAllNodes(){if(this._nodeCache.length<=32e3){for(const t in this._allNodes)if(this._allNodes.hasOwnProperty(t)){const i=this._allNodes[t];for(const h in i)i.hasOwnProperty(h)&&this._nodeCache.push(i[h])}}this._allNodes=[]}_insertNeighbors(t){this._addOrUpdateNode(t.pos[0]+1,t.pos[1],t,1),this._addOrUpdateNode(t.pos[0]-1,t.pos[1],t,1),this._addOrUpdateNode(t.pos[0],t.pos[1]+1,t,1),this._addOrUpdateNode(t.pos[0],t.pos[1]-1,t,1),this._allowDiagonals&&(this._addOrUpdateNode(t.pos[0]+1,t.pos[1]+1,t,1.414213562),this._addOrUpdateNode(t.pos[0]+1,t.pos[1]-1,t,1.414213562),this._addOrUpdateNode(t.pos[0]-1,t.pos[1]-1,t,1.414213562),this._addOrUpdateNode(t.pos[0]-1,t.pos[1]+1,t,1.414213562))}_getNode(t,i){if(this._allNodes.hasOwnProperty(t)){if(this._allNodes[t].hasOwnProperty(i))return this._allNodes[t][i]}else this._allNodes[t]=[];let h;this._nodeCache.length!==0?(h=this._nodeCache.shift(),h.reinitialize(t,i)):h=new c(t,i);const r=t*this._cellWidth+this._gridOffsetX,n=i*this._cellHeight+this._gridOffsetY;let a=!1;const _=this._cellHeight>this._cellWidth?this._cellHeight*2:this._cellWidth*2;this._obstacles.getAllObstaclesAround(r,n,_,this._closeObstacles);for(let g=0;g<this._closeObstacles.length;++g){const d=this._closeObstacles[g].owner,u=Math.floor((d.getDrawableX()-this._rightBorder-this._gridOffsetX)/this._cellWidth),m=Math.floor((d.getDrawableY()-this._bottomBorder-this._gridOffsetY)/this._cellHeight),O=Math.ceil((d.getDrawableX()+d.getWidth()+this._leftBorder-this._gridOffsetX)/this._cellWidth),S=Math.ceil((d.getDrawableY()+d.getHeight()+this._topBorder-this._gridOffsetY)/this._cellHeight);if(u<t&&t<O&&m<i&&i<S)if(a=!0,this._closeObstacles[g].isImpassable()){h.cost=-1;break}else h.cost+=this._closeObstacles[g].getCost()}return a||(h.cost=1),this._allNodes[t][i]=h,h}_addOrUpdateNode(t,i,h,r){const n=this._getNode(t,i);if(!(!n.open||n.cost<0)&&(n.smallestCost===-1||n.smallestCost>h.smallestCost+(h.cost+n.cost)/2*r)){if(n.smallestCost!=-1){for(let a=0;a<this._openNodes.length;++a)if(this._openNodes[a].pos[0]==n.pos[0]&&this._openNodes[a].pos[1]==n.pos[1]){this._openNodes.splice(a,1);break}}if(n.smallestCost=h.smallestCost+(h.cost+n.cost)/2*r,n.parent=h,n.estimateCost=n.smallestCost+this._distanceFunction(n.pos,this._destination),this._openNodes.length===0||this._openNodes[this._openNodes.length-1].estimateCost<n.estimateCost)this._openNodes.push(n);else for(let a=0;a<this._openNodes.length;++a)if(this._openNodes[a].estimateCost>=n.estimateCost){this._openNodes.splice(a,0,n);break}}}}e.SearchContext=s}(f=l.PathfindingRuntimeBehavior||(l.PathfindingRuntimeBehavior={}))})(gdjs||(gdjs={}));
//# sourceMappingURL=pathfindingruntimebehavior.js.map
